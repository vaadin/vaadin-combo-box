<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-combo basic tests</title>

  <script src="../../web-component-tester/browser.js"></script>
  <script src='../../webcomponentsjs/webcomponents-lite.js'></script>
  <link rel="import" href="../../test-fixture/test-fixture.html">
  <link rel="import" href="common-imports.html">
  <script src="common.js"></script>
  <link rel="import" href="../vaadin-combo-box-light.html">
  <link rel="import" href="../../iron-input/iron-input.html">
</head>

<body>

  <test-fixture id="comboBox">
    <template>
      <vaadin-combo-box></vaadin-combo-box>
    </template>
  </test-fixture>

  <test-fixture id="comboBoxLight">
    <template>
      <vaadin-combo-box-light attr-for-value="bind-value">
        <iron-input>
          <input>
        </iron-input>
      </vaadin-combo-box-light>
    </template>
  </test-fixture>

  <script>
    describe('lazy loading', () => {
      const DEFAULT_PAGE_SIZE = 50;
      const SIZE = 200;
      let dataProviderItems;

      const dataProvider = (params, callback) => {
        const offset = params.page * params.pageSize;
        const n = Math.min(offset + params.pageSize, SIZE) - offset;
        dataProviderItems = Array(...new Array(n)).map((_, i) => `item ${offset + i}`);
        callback(dataProviderItems, SIZE);
      };

      const spyDataProvider = sinon.spy(dataProvider);

      const spyAsyncDataProvider = sinon.spy((params, callback) => {
        setTimeout(() => dataProvider(params, callback));
      });

      beforeEach(() => {
        spyDataProvider.reset();
        spyAsyncDataProvider.reset();
      });

      let comboBox;

      const describeLazyLoading = () => {
        describe('dataProvider', () => {
          it('should not be invoked when set', () => {
            comboBox.dataProvider = spyDataProvider;
            expect(spyDataProvider).to.be.notCalled;
          });

          it('should be invoked on open', () => {
            comboBox.dataProvider = spyDataProvider;
            comboBox.opened = true;
            expect(spyDataProvider).to.be.calledOnce;
          });

          it('should be invoked with size set', () => {
            comboBox.size = SIZE;
            comboBox.dataProvider = spyDataProvider;
            comboBox.opened = true;
            expect(spyDataProvider).to.be.calledOnce;
          });

          it('should throw if set after items', () => {
            comboBox.items = ['foo'];
            function setDataProvider() {
              comboBox.dataProvider = spyDataProvider;
            }
            expect(setDataProvider).to.throw('not supported');
            expect(spyDataProvider).to.be.notCalled;
            expect(comboBox.dataProvider).to.be.undefined;
          });

          it('should throw if items are set after', () => {
            comboBox.dataProvider = spyDataProvider;
            function setItems() {
              comboBox.items = ['foo'];
            }
            expect(setItems).to.throw('not supported');
            expect(comboBox.items).to.be.undefined;
          });

          describe('when open', () => {
            beforeEach(() => comboBox.opened = true);

            it('should be invoked when set', () => {
              comboBox.dataProvider = spyDataProvider;
              expect(spyDataProvider).to.be.calledOnce;
            });

            it('should receive params argument', () => {
              comboBox.dataProvider = spyDataProvider;
              const params = spyDataProvider.lastCall.args[0];
              expect(typeof params).to.equal('object');
            });

            it('should have filter param', () => {
              comboBox.dataProvider = spyDataProvider;
              const params = spyDataProvider.lastCall.args[0];
              expect(params.filter).to.equal('');
            });

            it('should receive callback argument', () => {
              comboBox.dataProvider = spyDataProvider;
              const callback = spyDataProvider.lastCall.args[1];
              expect(typeof callback).to.equal('function');
            });

            it('should request page 0', () => {
              comboBox.dataProvider = spyDataProvider;
              const params = spyDataProvider.lastCall.args[0];
              expect(params.page).to.equal(0);
            });

            it('should request page 1 on scroll', () => {
              comboBox.dataProvider = spyDataProvider;
              spyDataProvider.reset();
              comboBox.$.overlay._scrollIntoView(75);
              expect(spyDataProvider).to.be.called;
              const pages = spyDataProvider.getCalls().map(call => call.args[0].page);
              expect(pages).to.contain(1);
            });

            it('should request page 2 on scroll', () => {
              comboBox.dataProvider = spyDataProvider;
              spyDataProvider.reset();
              comboBox.$.overlay._scrollIntoView(125);
              expect(spyDataProvider).to.be.called;
              const pages = spyDataProvider.getCalls().map(call => call.args[0].page);
              expect(pages).to.contain(2);
            });

            it('should request with empty filter', () => {
              comboBox.dataProvider = spyDataProvider;
              const params = spyDataProvider.lastCall.args[0];
              expect(params.filter).to.equal('');
            });

            it('should request on filter change with userâ€™s filter', () => {
              comboBox.dataProvider = spyDataProvider;
              spyDataProvider.reset();
              comboBox.filter = 'item 1';
              expect(spyDataProvider).to.be.called;
              const params = spyDataProvider.lastCall.args[0];
              expect(params.filter).to.equal('item 1');
            });

            it('should populate filteredItems', () => {
              expect(comboBox.filteredItems).to.be.undefined;
              comboBox.dataProvider = spyDataProvider;
              expect(comboBox.filteredItems).to.be.instanceof(Array);
              expect(comboBox.filteredItems.length).to.equal(SIZE);
              const filteredItemsFirstPage = comboBox.filteredItems.slice(0, comboBox.pageSize);
              expect(filteredItemsFirstPage).to.eql(dataProviderItems);
            });

            it('should toggle loading', done => {
              expect(comboBox.loading).to.be.false;
              comboBox.dataProvider = (params, callback) => {
                expect(comboBox.loading).to.be.true;
                callback([], 0);
                expect(comboBox.loading).to.be.false;
                done();
              };
            });
          });

          describe('async', () => {
            it('should be invoked on open', () => {
              comboBox.dataProvider = spyAsyncDataProvider;
              comboBox.opened = true;
              expect(spyAsyncDataProvider).to.be.calledOnce;
            });

            it('should be invoked on open with pre-defined size', () => {
              comboBox.size = SIZE;
              comboBox.dataProvider = spyAsyncDataProvider;
              comboBox.opened = true;
              expect(spyAsyncDataProvider).to.be.calledOnce;
            });

            it('should request page 1 on scroll', () => {
              comboBox.size = SIZE;
              comboBox.dataProvider = spyAsyncDataProvider;
              comboBox.opened = true;
              spyAsyncDataProvider.reset();
              comboBox.$.overlay._scrollIntoView(75);
              expect(spyAsyncDataProvider).to.be.called;
              const pages = spyAsyncDataProvider.getCalls().map(call => call.args[0].page);
              expect(pages).to.contain(1);
            });

            it('should request page 2 on scroll', () => {
              comboBox.size = SIZE;
              comboBox.dataProvider = spyAsyncDataProvider;
              comboBox.opened = true;
              spyAsyncDataProvider.reset();
              comboBox.$.overlay._scrollIntoView(125);
              expect(spyAsyncDataProvider).to.be.called;
              const pages = spyAsyncDataProvider.getCalls().map(call => call.args[0].page);
              expect(pages).to.contain(2);
            });

          });
        });

        describe('pageSize', () => {
          it('should have default value', () => {
            expect(typeof comboBox.pageSize).to.equal('number');
            expect(comboBox.pageSize).to.equal(DEFAULT_PAGE_SIZE);
          });

          it('should use default value in dataProvider', () => {
            comboBox.opened = true;
            comboBox.dataProvider = spyDataProvider;
            const params = spyDataProvider.lastCall.args[0];
            expect(typeof comboBox.pageSize).to.equal('number');
            expect(params.pageSize).to.equal(DEFAULT_PAGE_SIZE);
          });

          it('should use a custom value in dataProvider', () => {
            comboBox.opened = true;
            comboBox.pageSize = 123;
            comboBox.dataProvider = spyDataProvider;
            const params = spyDataProvider.lastCall.args[0];
            expect(params.pageSize).to.equal(123);
          });

          it('should throw when set to zero', () => {
            comboBox.pageSize = 123;
            expect(() => comboBox.pageSize = 0).to.throw('pageSize');
            expect(comboBox.pageSize).to.equal(123);
          });

          it('should throw when set to non-integer', () => {
            comboBox.pageSize = 123;
            expect(() => comboBox.pageSize = undefined).to.throw('pageSize');
            expect(() => comboBox.pageSize = null).to.throw('pageSize');
            expect(() => comboBox.pageSize = NaN).to.throw('pageSize');
            expect(() => comboBox.pageSize = 10.5).to.throw('pageSize');
            expect(() => comboBox.pageSize = '10').to.throw('pageSize');
            expect(comboBox.pageSize).to.equal(123);
          });
        });

        describe('size', () => {
          it('should not have default value', () => {
            expect(comboBox.size).to.be.undefined;
          });

          it('should be set from dataProvider callback', () => {
            comboBox.opened = true;
            comboBox.dataProvider = spyDataProvider;
            expect(comboBox.size).to.equal(SIZE);
          });
        });
      };

      describe('combo-box', () => {
        beforeEach(() => comboBox = fixture('comboBox'));

        describeLazyLoading();
      });

      describe('combo-box-light', () => {
        beforeEach(() => comboBox = fixture('comboBoxLight'));

        describeLazyLoading();
      });
    });
  </script>
