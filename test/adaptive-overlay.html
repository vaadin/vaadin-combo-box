<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-combo basic tests</title>
  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../test-fixture/test-fixture-mocha.js"></script>

  <link rel="import" href="common.html">
  <script src="../../promise-polyfill/Promise.js"></script>
  <script src="common.js"></script>
</head>

<body>

  <test-fixture id="overlay">
    <template>
      <div style="width: 100px; height: 100px;">
        <vaadin-adaptive-overlay>
          <div class="content">content</div>
        </vaadin-adaptive-overlay>
      </div>
    </template>
  </test-fixture>

  <test-fixture id="scrollable-overlay">
    <template>
      <div style="width: 100px; height: 100px;">
        <vaadin-adaptive-overlay>
          <div class="content" style="height:10000px">content</div>
        </vaadin-adaptive-overlay>
      </div>
    </template>
  </test-fixture>

  <script>
    describe('overlay modes', function() {
      var overlay;
      var content;
      var dropdownContent;
      var viewportInfo;

      beforeEach(function() {
        overlay = fixture('overlay').firstElementChild;
        content = Polymer.dom(overlay).querySelector('.content');
        dropdownContent = Polymer.dom(overlay.root).querySelector('.dropdown-content');
        viewportInfo = document.querySelector('meta[name="viewport"]');
      });

      describe('fullscreen', function() {

        beforeEach(function() {
          overlay.fullScreen = true;
          overlay.open();

          return waitUntilOpen(overlay);
        });

        it('should have correct dimensions', function() {
          var rect = overlay.$.dropdown.getBoundingClientRect();
          expect(rect.left).to.equal(0, 'left');
          expect(rect.top).to.equal(0, 'top');
          expect(dropdownContent.clientWidth).to.equal(document.documentElement.clientWidth);
          expect(dropdownContent.clientHeight).to.equal(document.documentElement.clientHeight);
        });

        it('should alter the viewport info', function() {
          expect(viewportInfo.content).to.equal(overlay._viewportInfo._fullScreenContent);
          overlay.close();

          return waitUntilClosed(overlay).then(function() {
            expect(viewportInfo.content).not.to.equal(overlay._viewportInfo._fullScreenContent);
          });
        });

        describeIf(ios, 'fullscreen ios', function() {
          it('should have correct target elements', function() {
            expect(overlay.$.dropdown.positionTarget).to.equal(null);
          });

          it('should have position absolute', function() {
            expect(window.getComputedStyle(overlay.$.dropdown, null).position).to.equal('absolute');
          });
        });

        describeSkipIf(ios, 'fullscreen not ios', function() {
          it('should have position fixed', function() {
            expect(window.getComputedStyle(overlay.$.dropdown, null).position).to.equal('fixed');
          });

          it('should have correct target elements', function() {
            expect(overlay.$.dropdown.positionTarget).to.equal(null);
          });
        });

      });

      describe('non-fullscreen', function() {

        beforeEach(function() {
          overlay.fullScreen = false;
          overlay.open();

          return waitUntilOpen(overlay);
        });

        it('should have correct target elements', function() {
          expect(overlay.$.dropdown.positionTarget).to.equal(null);
        });

        it('should have the same width as container has', function() {
          expect(overlay.$.dropdown.clientWidth).to.equal(100);
        });

        it('should have the height as content has', function() {
          // we have a 8px margin for the overlay.
          expect(overlay.$.dropdown.clientHeight).to.equal(content.clientHeight + 8);
        });

        it('should not alter the viewport info', function() {
          expect(viewportInfo.content).not.to.equal(overlay._viewportInfo._fullScreenContent);
        });

        it('should have device pixel accurate vertical coordinate for dropdown', function(done) {
          overlay.close();

          // Give offset by irrational number of pixels, that never results
          // into interger device pixel-accurate value when rendering
          overlay.parentElement.style.marginTop = Math.E + 'px';

          overlay.parentElement.style.float = 'left'; // disables margins collapsing

          var interval = setInterval(function() {
            if (overlay.$.dropdown._openChangedAsync) {
              return;
            }

            var target = overlay.$.dropdown.getBoundingClientRect().top;

            // When multiplied by `devicePixelRatio`, target should be integer
            expect(target * (window.devicePixelRatio || 1) % 1).to.be.equal(0);

            // Cleanup the inline styles
            overlay.parentElement.style.removeProperty('margin-top');
            overlay.parentElement.style.removeProperty('float');

            clearInterval(interval);
            done();
          }, 100);

          overlay.open();
        });
      });

      describe('scrolling in fullscreen mode', function() {
          beforeEach(function() {
            overlay = fixture('scrollable-overlay').firstElementChild;
            overlay.fullScreen = true;

            overlay.open();

            return waitUntilOpen(overlay);
          });

          it('should disallow outside scroll', function() {
            expect(overlay.$.dropdown.allowOutsideScroll).to.equal(false);
          });
      });

      describe('scrolling in desktop mode', function() {
        var overlay;

        function createWheelEvent(deltaY) {
          var e = new WheelEvent('wheel', {deltaY: deltaY});
          sinon.spy(e, 'preventDefault');

          return e;
        }

        function scrollUp(node) {
          var e = createWheelEvent(-1);
          node.dispatchEvent(e);

          return e;
        }

        function scrollDown(node) {
          var e = createWheelEvent(1);
          node.dispatchEvent(e);

          return e;
        }

        beforeEach(function() {
          overlay = fixture('scrollable-overlay').firstElementChild;
          overlay.fullScreen = false;

          overlay.open();

          return waitUntilOpen(overlay);
        });

        it('should allow outside scroll', function() {
          expect(overlay.$.dropdown.allowOutsideScroll).to.equal(true);
        });

        it('should prevent scrolling the body when at the top', function() {
          overlay.scroller.scrollTop = 0;

          var e = scrollUp(overlay);

          expect(e.preventDefault.callCount).to.equal(1);
        });

        it('should not prevent scrolling the contents contents up', function() {
          overlay.scroller.scrollTop = 1;

          var e = scrollUp(overlay);

          expect(e.preventDefault.callCount).to.equal(0);
        });

        it('should prevent scrolling the body when at the bottom', function() {
          // this is actually more than it's possible to scroll down,
          // but wanted to keep the test simple and not take the viewport height into account.
          overlay.scroller.scrollTop = 10000;

          var e = scrollDown(overlay);

          expect(e.preventDefault.callCount).to.equal(1);
        });

        it('should not prevent scrolling the contents contents down', function() {
          overlay.scroller.scrollTop = 1;

          var e = scrollDown(overlay);

          expect(e.preventDefault.callCount).to.equal(0);
        });
      });
    });
  </script>

</body>

</html>
