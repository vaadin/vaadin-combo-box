<!--
@element vaadin-adaptive-overlay
-->

<link rel='import' href='../polymer/polymer.html'>
<link rel='import' href='../iron-dropdown/iron-dropdown.html'>

<dom-module id="vaadin-adaptive-overlay">
  <style>
    :host {
      display: block;
      position: relative;
    }

    #dropdown[fullscreen],
    #dropdown[fullscreen]::content #contentWrapper,
    #dropdown[fullscreen] .dropdown-content {
      height: 100vh;
      max-height: 100vh;
      width: 100vw;
      max-width: 100vw;
    }

    .dropdown-content {
      width: 100vw;
      transform: translate3d(0, 0, 0);
      @apply(--dropdown-content);
    }

    #dropdown[vertical-align='bottom'] .dropdown-content {
      @apply(--dropdown-content-bottom-align);
    }

    #dropdown[ios][fullscreen] {
      position: absolute !important;
    }

    #dropdown:not([fullscreen]) {
      position: absolute !important;
      left: 0px !important;
    }

    /* Override the conflicting top/bottom values not cleared by iron-dropdown */
    #dropdown[vertical-align='top'] {
      bottom: auto !important;
    }
    #dropdown[vertical-align='bottom'] {
      top: auto !important;
    }
  </style>

  <template>
    <iron-dropdown id="dropdown" ios$=[[ios]]
      opened={{opened}}
      focus-target=[[focusTarget]]
      fullscreen$=[[fullScreen]]
      with-backdrop=[[fullScreen]]
      position-target="null"
      vertical-align=[[_verticalAlign]]
      vertical-offset=[[_verticalOffset]]
      on-tap="_tapped"
      on-iron-overlay-closed="_closed"
      on-iron-overlay-opened="_opened"
      allow-outside-scroll="[[_allowOutsideScroll(fullScreen)]]"
      on-iron-resize="_iOSRepositionAsync">
      <div id="dropdownContent" class="dropdown-content" on-touchend="_iOSRepositionAsync">
        <content>
      </div>
    </iron-dropdown>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-adaptive-overlay',

    properties: {
      /**
       * True if the overlay is open, false otherwise.
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false
      },

      /**
       * True if the overlay works in full screen mode (e.g. on mobile devices).
       */
      fullScreen: {
        type: Boolean,
        notify: true,
        reflectToAttribute: true,
        value: function() {
          try {
            document.createEvent('TouchEvent');
            return true;
          } catch (e) {
            return false;
          }
        }
      },

      /**
       * Current viewport config
       */
      _viewportInfo: {
        readOnly: true,
        value: function() {
          var viewport = document.querySelector('meta[name="viewport"]');
          if (!viewport) {
            viewport = document.createElement('meta');
            viewport.setAttribute('name', 'viewport');
            document.querySelector('head').appendChild(viewport);
          }
          viewport._originalContent = viewport.content;
          viewport._fullScreenContent =
            'width=device-width, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1, user-scalable=no';
          return viewport;
        }
      },

      /**
       * The pixel value that being compared with bottom offset of the input element will
       * make the popup be shown above the input.
       */
      alignThreshold: {
        type: Number,
        value: 200
      },

      /**
       * The element to position/align the dropdown by.
       */
      positionTarget: {
        computed: '_computePositionTarget(fullScreen)'
      },

      _resizeHandler: {
        value: function() {
          return this._updateOverlayAlignment.bind(this);
        }
      },

      _verticalAlign: {
        observer: '_verticalAlignChanged'
      },

      _verticalOffset: {
        type: Number,
        computed: '_computeVerticalOffset(opened,positionTarget,fullScreen,_verticalAlign)'
      },

      /**
       * True if running on an iOS device
       */
      ios: {
        value: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream
      },

      /**
        * Returns the scrollable element.
        *
        * @property scroller
        * @type Object
        */
      scroller: {
        type: Object,
        computed: '_scroller(fullScreen)'
      }
    },

    _scroller: function(fullScreen) {
      // with touch scrolling, default scroller element needs to be used.
      if (!this.fullScreen) {
        // For <iron-list> scrollToIndex() and _viewportSize to work in IE11,
        // we need to use #dropdownContent as scroller element.
        return this.$.dropdownContent;
      }
    },

    _allowOutsideScroll: function(fullScreen) {
      return !fullScreen;
    },

    _computePositionTarget: function(fullScreen) {
      return fullScreen ? document.documentElement : this.domHost || this.parentElement;
    },

    // In Safari, when dropdown is positioned on non-integer vertical
    // coordinate, the items text is sometimes rendered 1 device pixel line
    // outside the dropdown during vertical scrolling. We predict the vertical
    // coordinate of the dropdown and shift its offset by a small
    // error-correcting value, to make the vertical coordinate of the dropdown
    // an integer number of device pixels.
    _computeVerticalAdjustment: function(opened, positionTarget, fullScreen, _verticalAlign) {
      if (fullScreen) {
        return 0; // The adjustment is not necessary in the fullscreen mode
      }

      var positionRect = positionTarget.getBoundingClientRect();
      var positionValue = positionRect[_verticalAlign] + window.pageYOffset;
      var devicePixelRatio = window.devicePixelRatio || 1;
      var adjustment = Math.round(positionValue * devicePixelRatio) / devicePixelRatio - positionValue;
      return _verticalAlign === 'top' ? adjustment : -adjustment;
    },

    _computeVerticalOffset: function(opened, positionTarget, fullScreen, _verticalAlign) {
      var verticalOffset = (fullScreen || _verticalAlign == 'top') ? 0 : positionTarget.clientHeight;
      // Adjust vertical offset to make the position device pixel accurate integer
      verticalOffset += this._computeVerticalAdjustment(opened, positionTarget, fullScreen, _verticalAlign);
      return verticalOffset;
    },

    _verticalAlignChanged: function() {
      this.close();
      this.$.dropdown.resetFit();
      this.async(this.open);
    },

    /**
     * Need to monkeypatch _sizeDimension to fix sizingTarget width to match positionTarget width
     */
    _patchIronFitBehavior: function() {
      var sd = this.$.dropdown._sizeDimension.bind(this.$.dropdown);
      this.$.dropdown._sizeDimension = function(rect, positionedBy, start, end, extent) {
        if (extent === 'Width') {
          this.$.dropdown.sizingTarget.style.maxWidth = this.positionTarget.clientWidth + 'px';
        } else {
          sd(rect, positionedBy, start, end, extent);
        }
      }.bind(this);
    },

    ready: function() {
      this._patchIronFitBehavior();
    },

    /**
     * Open the overlay.
     */
    open: function() {
      this.$.dropdown.open();
    },

    /**
     * Close the overlay.
     */
    close: function() {
      this.$.dropdown.close();
    },

    /**
     * Called when an `iron-overlay-opened` event fires.
     */
    _opened: function() {
      if (this.fullScreen) {
        this._viewportInfo.content = this._viewportInfo._fullScreenContent;
      } else {
        this.$.dropdown.addEventListener('iron-resize', this._resizeHandler);
      }

      this._iOSOpened();
    },

    detached: function() {
      this._closed();
    },

    _updateOverlayPosition: function() {
      this.$.dropdown.style[this._verticalAlign] = this._verticalOffset + 'px';

      // Memoize the inline style for `IronFitBehavior`.
      if (this.$.dropdown._fitInfo) {
        this.$.dropdown._fitInfo.inlineStyle[this._verticalAlign] =
          this.$.dropdown.style[this._verticalAlign];
      }

      this.$.dropdown.refit();
    },

    _iOSOpened: function() {
      if (this.fullScreen && this.ios) {
        var rect = this.getBoundingClientRect();
        this.$.dropdown.style.left = -rect.left + 'px';
        this.$.dropdown.style.top = -rect.top + 'px';

        this._iOSReposition();
      }
    },

    /**
     * Called when an `iron-overlay-closed` event fires.
     */
    _closed: function() {
      if (this.fullScreen) {
        this._viewportInfo.content = this._viewportInfo._originalContent;
      } else {
        this.$.dropdown.removeEventListener('iron-resize', this._resizeHandler);
      }
    },

    /**
     * Called when the `iron-dropdown` is tapped.
     */
    _tapped: function(e) {
      if (this.fullScreen && e.target === this.$.dropdownContent) {
        // Tapped on the dropdown content instead of any actual element
        // inside the dropdown -> close the overlay.
        this.close();
      }
    },

    _updateOverlayAlignment: function() {
      var rect = this.positionTarget.getBoundingClientRect();
      var spaceBelow = window.innerHeight - rect.bottom;
      var alignedToBottom = spaceBelow < this.alignThreshold && spaceBelow < rect.top;
      this._verticalAlign = alignedToBottom ? 'bottom' : 'top';
      this._updateOverlayPosition();
    },

    _iOSRepositionAsync: function() {
      if (this.fullScreen && this.ios && this.opened) {
        this._iOSReposition();
        // Also reposition asynchronously as the scroll shift might
        // be delayed due to orientation change or focus animation.
        this.async(this._iOSReposition, 500);
      }
    },

    _iOSReposition: function() {
      if (this.fullScreen && this.ios && this.opened) {
        // Scroll back to the dropdown (scroll might have shifted due to input focus for example)
        var rect = this.$.dropdown.getBoundingClientRect();
        window.scrollBy(rect.left, rect.top);

        // Handle backdrop position
        this.async(function() {
          var backdrop = this.$.dropdown.backdropElement;
          backdrop.style.position = 'absolute';
          backdrop.style.left = '0';
          backdrop.style.top = '0';
          var rect = backdrop.getBoundingClientRect();
          backdrop.style.left = -rect.left + 'px';
          backdrop.style.top = -rect.top + 'px';
        });
      }
    }
  });
</script>
