<!--
@element vaadin-overlay
-->

<link rel='import' href='../polymer/polymer.html'>
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="vaadin-overlay">
  <style>
    :host {
      position: absolute;
      z-index: 10000;
      @apply(--layout-vertical);
      @apply(--shadow-elevation-2dp);
      background: #fff;
      border-radius: 0 0 2px 2px;
    }
  </style>

  <template>
    <content></content>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-overlay',

    behaviors: [
      Polymer.IronResizableBehavior
    ],

    properties: {
      /**
       * The element to position/align the dropdown by.
       */
      positionTarget: {
        type: Object
      },
      /**
       * Returns the scrollable element.
       *
       * @property scroller
       * @type Object
       */
      scroller: {
        type: Object
      },

      /**
       * Vertical offset for the overlay position.
       */
      verticalOffset: {
        type: Number,
        value: 0
      }
    },

    listeners: {
      'iron-resize': '_setOverlayPosition'
    },

    /**
     * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.
     * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow
     * scrolling the parent similarily to touch scrolling.
     */
    _patchWheelOverScrolling: function() {
      if (this.scroller) {
        this.addEventListener('wheel', function(e) {
          var scrolledToTop = this.scroller.scrollTop === 0;
          var scrolledToBottom = (this.scroller.scrollHeight - this.scroller.scrollTop - this.scroller.clientHeight) === 0;

          if (scrolledToTop && e.deltaY < 0) {
            e.preventDefault();
          } else if (scrolledToBottom && e.deltaY > 0) {
            e.preventDefault();
          }
        }.bind(this));
      }
    },

    ready: function() {
      this._patchWheelOverScrolling();
    },

    attached: function() {
      this._setOverlayPosition();
    },

    // If document.body doesn't have position:static, we need to deduct the body margins from
    // the overlay position. Alternatively, the margins could be added directly to top and left properties.
    _setMargins: function() {
      var styles = window.getComputedStyle(document.body);

      this.style.marginTop = styles.position === 'static' ? 0 : '-' + styles.marginTop;
      this.style.marginLeft = styles.position === 'static' ? 0 : '-' + styles.marginLeft;
    },

    _setOverlayPosition: function() {
      var bodyRect = document.body.getBoundingClientRect();
      var target = this.positionTarget;
      var targetRect = target.getBoundingClientRect();

      this.style.top = targetRect.top + (document.body.scrollTop || document.documentElement.scrollTop) +
                       target.clientHeight + this.verticalOffset + 'px';
      this.style.left = targetRect.left + (document.body.scrollLeft || document.documentElement.scrollLeft) + 'px';
      this._setMargins();

      this.style.width = this.positionTarget.clientWidth + 'px';
    }
  });
</script>
