<!--
@element vaadin-overlay
-->

<link rel='import' href='../polymer/polymer.html'>
<link rel='import' href='../iron-fit-behavior/iron-fit-behavior.html'>
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="vaadin-overlay">
  <style>
    :host {
      position: absolute;
      z-index: 10000;
      @apply(--layout-vertical);
      @apply(--shadow-elevation-2dp);
      background: #fff;
      border-radius: 0 0 2px 2px;
    }
  </style>

  <template>
    <content></content>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-overlay',

    behaviors: [
      Polymer.IronFitBehavior,
      Polymer.IronResizableBehavior
    ],

    properties: {
      /**
       * The element to position/align the dropdown by.
       */
      positionTarget: {
        type: Object
      },
      /**
       * Returns the scrollable element.
       *
       * @property scroller
       * @type Object
       */
      scroller: {
        type: Object
      }
    },

    listeners: {
      'iron-resize': '_setOverlayPosition'
    },

    /**
     * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.
     * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow
     * scrolling the parent similarily to touch scrolling.
     */
    _patchWheelOverScrolling: function() {
      if (this.scroller) {
        this.addEventListener('wheel', function(e) {
          var scrolledToTop = this.scroller.scrollTop === 0;
          var scrolledToBottom = (this.scroller.scrollHeight - this.scroller.scrollTop - this.scroller.clientHeight) === 0;

          if (scrolledToTop && e.deltaY < 0) {
            e.preventDefault();
          } else if (scrolledToBottom && e.deltaY > 0) {
            e.preventDefault();
          }
        }.bind(this));
      }
    },

    /**
     * Need to monkeypatch _sizeDimension to fix sizingTarget width to match positionTarget width
     */
    _patchIronFitBehavior: function() {
      var sd = this._sizeDimension.bind(this);
      this._sizeDimension = function(rect, positionedBy, start, end, extent) {
        if (extent === 'Width') {
          this.sizingTarget.style.width = this.positionTarget.clientWidth + 'px';
        } else {
          sd(rect, positionedBy, start, end, extent);
        }
      }.bind(this);
    },

    ready: function() {
      this._patchWheelOverScrolling();
      this._patchIronFitBehavior();
    },

    attached: function() {
      this._setOverlayPosition();
    },

    // Helper method to get the height of possible underline used in paper-input-container.
    // The underline height is not included in the client height of the <vaadin-dropdown>.
    _underlineHeight: function(target) {
      var underline = target.querySelector('.underline');

      if (underline) {
        return underline.querySelector('.focused-line').clientHeight;
      } else {
        return 0;
      }
    },

    // If document.body doesn't have position:static, we need to deduct the body margins from
    // the overlay position. Alternatively, the margins could be added directly to top and left properties.
    _setMargins: function() {
      var styles = window.getComputedStyle(document.body);

      this.style.marginTop = styles.position === 'static' ? 0 : '-' + styles.marginTop;
      this.style.marginLeft = styles.position === 'static' ? 0 : '-' + styles.marginLeft;
    },

    _setOverlayPosition: function() {
      var bodyRect = document.body.getBoundingClientRect();
      var target = this.positionTarget;
      var targetRect = target.getBoundingClientRect();

      this.style.top = targetRect.top + (document.body.scrollTop || document.documentElement.scrollTop) + target.clientHeight + this._underlineHeight(target) + 'px';
      this.style.left = targetRect.left + (document.body.scrollLeft || document.documentElement.scrollLeft) + 'px';
      this._setMargins();

      this.fit();
    }
  });
</script>
